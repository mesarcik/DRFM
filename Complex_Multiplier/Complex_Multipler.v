// megafunction wizard: %ALTMULT_COMPLEX%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altmult_complex 

// ============================================================
// File Name: Complex_Multipler.v
// Megafunction Name(s):
// 			altmult_complex
//
// Simulation Library Files(s):
// 			altera_mf;lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 16.1.0 Build 196 10/24/2016 SJ Lite Edition
// ************************************************************


//Copyright (C) 2016  Intel Corporation. All rights reserved.
//Your use of Intel Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Intel Program License 
//Subscription Agreement, the Intel Quartus Prime License Agreement,
//the Intel MegaCore Function License Agreement, or other 
//applicable license agreement, including, without limitation, 
//that your use is for the sole purpose of programming logic 
//devices manufactured by Intel and sold by Intel or its 
//authorized distributors.  Please refer to the applicable 
//agreement for further details.


//altmult_complex CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="MAX 10" IMPLEMENTATION_STYLE="AUTO" PIPELINE=0 REPRESENTATION_A="SIGNED" REPRESENTATION_B="SIGNED" WIDTH_A=16 WIDTH_B=17 WIDTH_RESULT=33 dataa_imag dataa_real datab_imag datab_real result_imag result_real
//VERSION_BEGIN 16.1 cbx_alt_ded_mult_y 2016:10:24:15:04:16:SJ cbx_altera_mult_add 2016:10:24:15:04:16:SJ cbx_altera_mult_add_rtl 2016:10:24:15:04:16:SJ cbx_altmult_add 2016:10:24:15:04:16:SJ cbx_altmult_complex 2016:10:24:15:04:16:SJ cbx_arriav 2016:10:24:15:04:16:SJ cbx_cycloneii 2016:10:24:15:04:16:SJ cbx_lpm_add_sub 2016:10:24:15:04:16:SJ cbx_lpm_compare 2016:10:24:15:04:16:SJ cbx_lpm_mult 2016:10:24:15:04:16:SJ cbx_mgl 2016:10:24:15:05:03:SJ cbx_nadder 2016:10:24:15:04:16:SJ cbx_padd 2016:10:24:15:04:16:SJ cbx_parallel_add 2016:10:24:15:04:16:SJ cbx_stratix 2016:10:24:15:04:16:SJ cbx_stratixii 2016:10:24:15:04:16:SJ cbx_stratixv 2016:10:24:15:04:16:SJ cbx_util_mgl 2016:10:24:15:04:16:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = altmult_add 3 lpm_add_sub 6 lpm_compare 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Complex_Multipler_altmult_complex_e2o
	( 
	dataa_imag,
	dataa_real,
	datab_imag,
	datab_real,
	result_imag,
	result_real) ;
	input   [15:0]  dataa_imag;
	input   [15:0]  dataa_real;
	input   [16:0]  datab_imag;
	input   [16:0]  datab_real;
	output   [32:0]  result_imag;
	output   [32:0]  result_real;

	wire  [32:0]   wire_product1_result;
	wire  [32:0]   wire_product2_result;
	wire  [34:0]   wire_product3_result;
	wire  [33:0]   wire_add_sub1_result;
	wire  [16:0]   wire_adder1_result;
	wire  [33:0]   wire_adder2_result;
	wire  [17:0]   wire_subtractor1_result;
	wire  [33:0]   wire_subtractor2_result;
	wire  [34:0]   wire_subtractor3_result;
	wire  wire_comparator1_alb;
	wire  [16:0]  add1_res;
	wire  [0:0]  gnd_value;
	wire  [35:0]  inputa_imag;
	wire  [35:0]  inputa_real;
	wire  [35:0]  inputb_imag;
	wire  [35:0]  inputb_real;
	wire  [32:0]  product1_res;
	wire  [32:0]  product2_res;
	wire  [33:0]  product3_res;
	wire  [17:0]  sub1_res;
	wire  [33:0]  sub2_res;

	altmult_add   product1
	( 
	.chainout_sat_overflow(),
	.dataa(inputa_real[15:0]),
	.datab(inputb_imag[16:0]),
	.mult0_is_saturated(),
	.mult1_is_saturated(),
	.mult2_is_saturated(),
	.mult3_is_saturated(),
	.overflow(),
	.result(wire_product1_result),
	.scanouta(),
	.scanoutb()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.accum_sload(1'b0),
	.aclr0(1'b0),
	.aclr1(1'b0),
	.aclr2(1'b0),
	.aclr3(1'b0),
	.addnsub1(1'b1),
	.addnsub1_round(1'b0),
	.addnsub3(1'b1),
	.addnsub3_round(1'b0),
	.chainin({1{1'b0}}),
	.chainout_round(1'b0),
	.chainout_saturate(1'b0),
	.clock0(1'b1),
	.clock1(1'b1),
	.clock2(1'b1),
	.clock3(1'b1),
	.coefsel0({3{1'b0}}),
	.coefsel1({3{1'b0}}),
	.coefsel2({3{1'b0}}),
	.coefsel3({3{1'b0}}),
	.datac({22{1'b0}}),
	.ena0(1'b1),
	.ena1(1'b1),
	.ena2(1'b1),
	.ena3(1'b1),
	.mult01_round(1'b0),
	.mult01_saturation(1'b0),
	.mult23_round(1'b0),
	.mult23_saturation(1'b0),
	.output_round(1'b0),
	.output_saturate(1'b0),
	.rotate(1'b0),
	.scanina({16{1'b0}}),
	.scaninb({17{1'b0}}),
	.shift_right(1'b0),
	.signa(1'b0),
	.signb(1'b0),
	.sourcea({1{1'b0}}),
	.sourceb({1{1'b0}}),
	.zero_chainout(1'b0),
	.zero_loopback(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		product1.input_register_a0 = "UNREGISTERED",
		product1.input_register_b0 = "UNREGISTERED",
		product1.multiplier_register0 = "UNREGISTERED",
		product1.number_of_multipliers = 1,
		product1.output_register = "UNREGISTERED",
		product1.port_addnsub1 = "PORT_UNUSED",
		product1.port_signa = "PORT_UNUSED",
		product1.port_signb = "PORT_UNUSED",
		product1.representation_a = "SIGNED",
		product1.representation_b = "SIGNED",
		product1.width_a = 16,
		product1.width_b = 17,
		product1.width_result = 33,
		product1.lpm_type = "altmult_add";
	altmult_add   product2
	( 
	.chainout_sat_overflow(),
	.dataa(inputa_imag[15:0]),
	.datab(inputb_real[16:0]),
	.mult0_is_saturated(),
	.mult1_is_saturated(),
	.mult2_is_saturated(),
	.mult3_is_saturated(),
	.overflow(),
	.result(wire_product2_result),
	.scanouta(),
	.scanoutb()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.accum_sload(1'b0),
	.aclr0(1'b0),
	.aclr1(1'b0),
	.aclr2(1'b0),
	.aclr3(1'b0),
	.addnsub1(1'b1),
	.addnsub1_round(1'b0),
	.addnsub3(1'b1),
	.addnsub3_round(1'b0),
	.chainin({1{1'b0}}),
	.chainout_round(1'b0),
	.chainout_saturate(1'b0),
	.clock0(1'b1),
	.clock1(1'b1),
	.clock2(1'b1),
	.clock3(1'b1),
	.coefsel0({3{1'b0}}),
	.coefsel1({3{1'b0}}),
	.coefsel2({3{1'b0}}),
	.coefsel3({3{1'b0}}),
	.datac({22{1'b0}}),
	.ena0(1'b1),
	.ena1(1'b1),
	.ena2(1'b1),
	.ena3(1'b1),
	.mult01_round(1'b0),
	.mult01_saturation(1'b0),
	.mult23_round(1'b0),
	.mult23_saturation(1'b0),
	.output_round(1'b0),
	.output_saturate(1'b0),
	.rotate(1'b0),
	.scanina({16{1'b0}}),
	.scaninb({17{1'b0}}),
	.shift_right(1'b0),
	.signa(1'b0),
	.signb(1'b0),
	.sourcea({1{1'b0}}),
	.sourceb({1{1'b0}}),
	.zero_chainout(1'b0),
	.zero_loopback(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		product2.input_register_a0 = "UNREGISTERED",
		product2.input_register_b0 = "UNREGISTERED",
		product2.multiplier_register0 = "UNREGISTERED",
		product2.number_of_multipliers = 1,
		product2.output_register = "UNREGISTERED",
		product2.port_addnsub1 = "PORT_UNUSED",
		product2.port_signa = "PORT_UNUSED",
		product2.port_signb = "PORT_UNUSED",
		product2.representation_a = "SIGNED",
		product2.representation_b = "SIGNED",
		product2.width_a = 16,
		product2.width_b = 17,
		product2.width_result = 33,
		product2.lpm_type = "altmult_add";
	altmult_add   product3
	( 
	.chainout_sat_overflow(),
	.dataa(add1_res[16:0]),
	.datab(sub1_res),
	.mult0_is_saturated(),
	.mult1_is_saturated(),
	.mult2_is_saturated(),
	.mult3_is_saturated(),
	.overflow(),
	.result(wire_product3_result),
	.scanouta(),
	.scanoutb()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.accum_sload(1'b0),
	.aclr0(1'b0),
	.aclr1(1'b0),
	.aclr2(1'b0),
	.aclr3(1'b0),
	.addnsub1(1'b1),
	.addnsub1_round(1'b0),
	.addnsub3(1'b1),
	.addnsub3_round(1'b0),
	.chainin({1{1'b0}}),
	.chainout_round(1'b0),
	.chainout_saturate(1'b0),
	.clock0(1'b1),
	.clock1(1'b1),
	.clock2(1'b1),
	.clock3(1'b1),
	.coefsel0({3{1'b0}}),
	.coefsel1({3{1'b0}}),
	.coefsel2({3{1'b0}}),
	.coefsel3({3{1'b0}}),
	.datac({22{1'b0}}),
	.ena0(1'b1),
	.ena1(1'b1),
	.ena2(1'b1),
	.ena3(1'b1),
	.mult01_round(1'b0),
	.mult01_saturation(1'b0),
	.mult23_round(1'b0),
	.mult23_saturation(1'b0),
	.output_round(1'b0),
	.output_saturate(1'b0),
	.rotate(1'b0),
	.scanina({17{1'b0}}),
	.scaninb({18{1'b0}}),
	.shift_right(1'b0),
	.signa(1'b0),
	.signb(1'b0),
	.sourcea({1{1'b0}}),
	.sourceb({1{1'b0}}),
	.zero_chainout(1'b0),
	.zero_loopback(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		product3.input_register_a0 = "UNREGISTERED",
		product3.input_register_b0 = "UNREGISTERED",
		product3.multiplier_register0 = "UNREGISTERED",
		product3.number_of_multipliers = 1,
		product3.output_register = "UNREGISTERED",
		product3.port_addnsub1 = "PORT_UNUSED",
		product3.port_signa = "PORT_UNUSED",
		product3.port_signb = "PORT_UNUSED",
		product3.representation_a = "SIGNED",
		product3.representation_b = "SIGNED",
		product3.width_a = 17,
		product3.width_b = 18,
		product3.width_result = 35,
		product3.lpm_type = "altmult_add";
	lpm_add_sub   add_sub1
	( 
	.cout(),
	.dataa({sub2_res[33:0]}),
	.datab({product3_res[33:0]}),
	.overflow(),
	.result(wire_add_sub1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.add_sub(1'b1),
	.cin(),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub1.lpm_direction = "ADD",
		add_sub1.lpm_width = 34,
		add_sub1.lpm_type = "lpm_add_sub";
	lpm_add_sub   adder1
	( 
	.cout(),
	.dataa({inputa_real[15], inputa_real[15:0]}),
	.datab({inputa_imag[15], inputa_imag[15:0]}),
	.overflow(),
	.result(wire_adder1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.add_sub(1'b1),
	.cin(),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		adder1.lpm_direction = "ADD",
		adder1.lpm_representation = "SIGNED",
		adder1.lpm_width = 17,
		adder1.lpm_type = "lpm_add_sub";
	lpm_add_sub   adder2
	( 
	.cout(),
	.dataa({product1_res[32], product1_res}),
	.datab({product2_res[32], product2_res}),
	.overflow(),
	.result(wire_adder2_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.add_sub(1'b1),
	.cin(),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		adder2.lpm_direction = "ADD",
		adder2.lpm_representation = "SIGNED",
		adder2.lpm_width = 34,
		adder2.lpm_type = "lpm_add_sub";
	lpm_add_sub   subtractor1
	( 
	.cout(),
	.dataa({inputb_real[16], inputb_real[16:0]}),
	.datab({inputb_imag[16], inputb_imag[16:0]}),
	.overflow(),
	.result(wire_subtractor1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.add_sub(1'b1),
	.cin(),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		subtractor1.lpm_direction = "SUB",
		subtractor1.lpm_representation = "SIGNED",
		subtractor1.lpm_width = 18,
		subtractor1.lpm_type = "lpm_add_sub";
	lpm_add_sub   subtractor2
	( 
	.cout(),
	.dataa({product1_res[32], product1_res}),
	.datab({product2_res[32], product2_res}),
	.overflow(),
	.result(wire_subtractor2_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.add_sub(1'b1),
	.cin(),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		subtractor2.lpm_direction = "SUB",
		subtractor2.lpm_representation = "SIGNED",
		subtractor2.lpm_width = 34,
		subtractor2.lpm_type = "lpm_add_sub";
	lpm_add_sub   subtractor3
	( 
	.cout(),
	.dataa({35{gnd_value}}),
	.datab({wire_product3_result[34:0]}),
	.overflow(),
	.result(wire_subtractor3_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.add_sub(1'b1),
	.cin(),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		subtractor3.lpm_direction = "ADD",
		subtractor3.lpm_representation = "UNSIGNED",
		subtractor3.lpm_width = 35,
		subtractor3.lpm_type = "lpm_add_sub";
	lpm_compare   comparator1
	( 
	.aeb(),
	.agb(),
	.ageb(),
	.alb(wire_comparator1_alb),
	.aleb(),
	.aneb(),
	.dataa(datab_real),
	.datab(datab_imag)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		comparator1.lpm_representation = "SIGNED",
		comparator1.lpm_width = 17,
		comparator1.lpm_type = "lpm_compare";
	assign
		add1_res = wire_adder1_result,
		gnd_value = 1'b0,
		inputa_imag = {{20{inputa_imag[15]}}, dataa_imag[15:0]},
		inputa_real = {{20{inputa_real[15]}}, dataa_real[15:0]},
		inputb_imag = {{19{inputb_imag[16]}}, datab_imag[16:0]},
		inputb_real = {{19{inputb_real[16]}}, datab_real[16:0]},
		product1_res = wire_product1_result,
		product2_res = wire_product2_result,
		product3_res = {wire_subtractor3_result[33:0]},
		result_imag = wire_adder2_result[32:0],
		result_real = wire_add_sub1_result[32:0],
		sub1_res = wire_subtractor1_result,
		sub2_res = wire_subtractor2_result;
endmodule //Complex_Multipler_altmult_complex_e2o
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module Complex_Multipler (
	dataa_imag,
	dataa_real,
	datab_imag,
	datab_real,
	result_imag,
	result_real);

	input	[15:0]  dataa_imag;
	input	[15:0]  dataa_real;
	input	[16:0]  datab_imag;
	input	[16:0]  datab_real;
	output	[32:0]  result_imag;
	output	[32:0]  result_real;

	wire [32:0] sub_wire0;
	wire [32:0] sub_wire1;
	wire [32:0] result_imag = sub_wire0[32:0];
	wire [32:0] result_real = sub_wire1[32:0];

	Complex_Multipler_altmult_complex_e2o	Complex_Multipler_altmult_complex_e2o_component (
				.dataa_imag (dataa_imag),
				.dataa_real (dataa_real),
				.datab_imag (datab_imag),
				.datab_real (datab_real),
				.result_imag (sub_wire0),
				.result_real (sub_wire1));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "MAX 10"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: CONSTANT: IMPLEMENTATION_STYLE STRING "AUTO"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "MAX 10"
// Retrieval info: CONSTANT: PIPELINE NUMERIC "0"
// Retrieval info: CONSTANT: REPRESENTATION_A STRING "SIGNED"
// Retrieval info: CONSTANT: REPRESENTATION_B STRING "SIGNED"
// Retrieval info: CONSTANT: WIDTH_A NUMERIC "16"
// Retrieval info: CONSTANT: WIDTH_B NUMERIC "17"
// Retrieval info: CONSTANT: WIDTH_RESULT NUMERIC "33"
// Retrieval info: USED_PORT: dataa_imag 0 0 16 0 INPUT NODEFVAL "dataa_imag[15..0]"
// Retrieval info: USED_PORT: dataa_real 0 0 16 0 INPUT NODEFVAL "dataa_real[15..0]"
// Retrieval info: USED_PORT: datab_imag 0 0 17 0 INPUT NODEFVAL "datab_imag[16..0]"
// Retrieval info: USED_PORT: datab_real 0 0 17 0 INPUT NODEFVAL "datab_real[16..0]"
// Retrieval info: USED_PORT: result_imag 0 0 33 0 OUTPUT NODEFVAL "result_imag[32..0]"
// Retrieval info: USED_PORT: result_real 0 0 33 0 OUTPUT NODEFVAL "result_real[32..0]"
// Retrieval info: CONNECT: @dataa_imag 0 0 16 0 dataa_imag 0 0 16 0
// Retrieval info: CONNECT: @dataa_real 0 0 16 0 dataa_real 0 0 16 0
// Retrieval info: CONNECT: @datab_imag 0 0 17 0 datab_imag 0 0 17 0
// Retrieval info: CONNECT: @datab_real 0 0 17 0 datab_real 0 0 17 0
// Retrieval info: CONNECT: result_imag 0 0 33 0 @result_imag 0 0 33 0
// Retrieval info: CONNECT: result_real 0 0 33 0 @result_real 0 0 33 0
// Retrieval info: LIB_FILE: altera_mf
// Retrieval info: LIB_FILE: lpm
